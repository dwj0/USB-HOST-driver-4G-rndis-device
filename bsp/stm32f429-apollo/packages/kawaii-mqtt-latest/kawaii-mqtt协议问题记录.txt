2020年6月28日
1、platform_thread.c函数中的创建线程，删除线程的方式存在使用已经释放的内存的问题，修改platform_thread_init函数内部采用rt_thread_creat方式创建 ，线程释放时调用的platform_thread_destroy函数置空线程指针就可以了，  已经修改

2、mqtt_send_packet函数内部已经对timer变量进行了初始化和操作，把timer变量内置为此函数的局部变量，相关外部调用不用初始化， 有一个个例的地方：mqtt_connect_with_results函数的第1005  1008行发送包和接收包函数都会使用同一个connect_timer，这里要求此变量外置。 已经修改

3、platform_timer_init(&timer);
    platform_timer_cutdown(&timer, c->mqtt_cmd_timeout);这两个函数都是对同一变量进行赋值，建议去除第一个函数，已经修改，删除第一个函数  已经修改

4、mqtt_connect_with_results，内部申请的发送与接收缓冲区放到mqtt_lease函数中进行。解决多次重新连接导致的内存泄漏
        连接失败时，不执行释放platform_memory_free(c->mqtt_network),方便下次接着使用。
       1025行启动函数只执行一次就可以，删除下和行的。
       增加创建线程失败的打印，位于1031行，同时断开链接    已经修改完成

5、ack list链表的写入访问采用c->mqtt_write_lock信号量来进行保护， mqtt_publish_packet_handle函数中的调用mqtt_ack_list_record未进行保护？

6、mqtt_ack_list_unrecord函数对链表的操作没有被c->mqtt_write_lock进行保护？这是为什么  已经修改

7、mqtt连接断开再重连时，出现内存耗用增加64字节-128字节不等的情况。这时由于断开重新连接网络后mqtt_subscribe函数重新订阅，申请的内存导致的，这里的链表的处理导致内存泄漏了。

说明：修改了7，4的内存泄漏的地方后，第一次连接网络后，占用动态内存为22616，断开网线后，再次连网动态内存占用22620，之后测试三次断开再连接动态内存占用为22620。也就是说第二次以后，内存占用多了4个字节。
         修改了5， 即对所有链表操作地方增加了互斥信号量保护后，第一次连接网络后，占用动态内存为22616，断开网线后，再次连网动态内存占用22616，后面又进行了三次断网，连接后，内存占用22616。动态内存保持稳定了。

8、需要在mqtt重新连接网络之前，设置一个回调函数，用于更新连接的password，因为onenet平台连接需要支持动态密钥的方式，密钥与时间相关联并且发生变化 。解决方法：原来程序的mqtt_reconnect_handler的回调函数，进行连接前的重新回调用。删除程序中重连定时器变量,只使用重新连接的周期变量。


测试用例：
1、测试连网时的长时间的稳定性，注意观察内存占用
2、测试长时间断网时的稳定性，注意观察内存占用
3、测试平台侧给设备大量发送数据的稳定性，包括发送数据过程中断开网络，再重新连接上，注意观察内存占用

